/*components/jquery-ui/jquery-ui*/
define("components/jquery-ui/jquery-ui",["can/","./jquery-ui.stache!","ui/accordion","jquery"],function(e,t,u,r){"use strict";e&&e.__esModule||(e={"default":e}),t&&t.__esModule||(t={"default":t}),u&&u.__esModule||(u={"default":u}),r&&r.__esModule||(r={"default":r});var n=$traceurRuntime.assertObject(e).default,c=$traceurRuntime.assertObject(t).default,a=($traceurRuntime.assertObject(u).default,$traceurRuntime.assertObject(r).default),o=n.Component.extend({tag:"sc-jquery-ui",template:c,scope:{},helpers:{accordion:function(){return function(e){a(e).one("inserted",function(){a(e).accordion()})}}}});return{get default(){return o},__esModule:!0}});
/*ui/accordion*/
System.define("ui/accordion",'/*!\n * jQuery UI Accordion 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/accordion/\n *\n * Depends:\n *	jquery.ui.core.js\n *	jquery.ui.widget.js\n */\n(function( $, undefined ) {\n\nvar uid = 0,\n	hideProps = {},\n	showProps = {};\n\nhideProps.height = hideProps.paddingTop = hideProps.paddingBottom =\n	hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";\nshowProps.height = showProps.paddingTop = showProps.paddingBottom =\n	showProps.borderTopWidth = showProps.borderBottomWidth = "show";\n\n$.widget( "ui.accordion", {\n	version: "1.10.4",\n	options: {\n		active: 0,\n		animate: {},\n		collapsible: false,\n		event: "click",\n		header: "> li > :first-child,> :not(li):even",\n		heightStyle: "auto",\n		icons: {\n			activeHeader: "ui-icon-triangle-1-s",\n			header: "ui-icon-triangle-1-e"\n		},\n\n		// callbacks\n		activate: null,\n		beforeActivate: null\n	},\n\n	_create: function() {\n		var options = this.options;\n		this.prevShow = this.prevHide = $();\n		this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )\n			// ARIA\n			.attr( "role", "tablist" );\n\n		// don\'t allow collapsible: false and active: false / null\n		if ( !options.collapsible && (options.active === false || options.active == null) ) {\n			options.active = 0;\n		}\n\n		this._processPanels();\n		// handle negative values\n		if ( options.active < 0 ) {\n			options.active += this.headers.length;\n		}\n		this._refresh();\n	},\n\n	_getCreateEventData: function() {\n		return {\n			header: this.active,\n			panel: !this.active.length ? $() : this.active.next(),\n			content: !this.active.length ? $() : this.active.next()\n		};\n	},\n\n	_createIcons: function() {\n		var icons = this.options.icons;\n		if ( icons ) {\n			$( "<span>" )\n				.addClass( "ui-accordion-header-icon ui-icon " + icons.header )\n				.prependTo( this.headers );\n			this.active.children( ".ui-accordion-header-icon" )\n				.removeClass( icons.header )\n				.addClass( icons.activeHeader );\n			this.headers.addClass( "ui-accordion-icons" );\n		}\n	},\n\n	_destroyIcons: function() {\n		this.headers\n			.removeClass( "ui-accordion-icons" )\n			.children( ".ui-accordion-header-icon" )\n				.remove();\n	},\n\n	_destroy: function() {\n		var contents;\n\n		// clean up main element\n		this.element\n			.removeClass( "ui-accordion ui-widget ui-helper-reset" )\n			.removeAttr( "role" );\n\n		// clean up headers\n		this.headers\n			.removeClass( "ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )\n			.removeAttr( "role" )\n			.removeAttr( "aria-expanded" )\n			.removeAttr( "aria-selected" )\n			.removeAttr( "aria-controls" )\n			.removeAttr( "tabIndex" )\n			.each(function() {\n				if ( /^ui-accordion/.test( this.id ) ) {\n					this.removeAttribute( "id" );\n				}\n			});\n		this._destroyIcons();\n\n		// clean up content panels\n		contents = this.headers.next()\n			.css( "display", "" )\n			.removeAttr( "role" )\n			.removeAttr( "aria-hidden" )\n			.removeAttr( "aria-labelledby" )\n			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled" )\n			.each(function() {\n				if ( /^ui-accordion/.test( this.id ) ) {\n					this.removeAttribute( "id" );\n				}\n			});\n		if ( this.options.heightStyle !== "content" ) {\n			contents.css( "height", "" );\n		}\n	},\n\n	_setOption: function( key, value ) {\n		if ( key === "active" ) {\n			// _activate() will handle invalid values and update this.options\n			this._activate( value );\n			return;\n		}\n\n		if ( key === "event" ) {\n			if ( this.options.event ) {\n				this._off( this.headers, this.options.event );\n			}\n			this._setupEvents( value );\n		}\n\n		this._super( key, value );\n\n		// setting collapsible: false while collapsed; open first panel\n		if ( key === "collapsible" && !value && this.options.active === false ) {\n			this._activate( 0 );\n		}\n\n		if ( key === "icons" ) {\n			this._destroyIcons();\n			if ( value ) {\n				this._createIcons();\n			}\n		}\n\n		// #5332 - opacity doesn\'t cascade to positioned elements in IE\n		// so we need to add the disabled class to the headers and panels\n		if ( key === "disabled" ) {\n			this.headers.add( this.headers.next() )\n				.toggleClass( "ui-state-disabled", !!value );\n		}\n	},\n\n	_keydown: function( event ) {\n		if ( event.altKey || event.ctrlKey ) {\n			return;\n		}\n\n		var keyCode = $.ui.keyCode,\n			length = this.headers.length,\n			currentIndex = this.headers.index( event.target ),\n			toFocus = false;\n\n		switch ( event.keyCode ) {\n			case keyCode.RIGHT:\n			case keyCode.DOWN:\n				toFocus = this.headers[ ( currentIndex + 1 ) % length ];\n				break;\n			case keyCode.LEFT:\n			case keyCode.UP:\n				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];\n				break;\n			case keyCode.SPACE:\n			case keyCode.ENTER:\n				this._eventHandler( event );\n				break;\n			case keyCode.HOME:\n				toFocus = this.headers[ 0 ];\n				break;\n			case keyCode.END:\n				toFocus = this.headers[ length - 1 ];\n				break;\n		}\n\n		if ( toFocus ) {\n			$( event.target ).attr( "tabIndex", -1 );\n			$( toFocus ).attr( "tabIndex", 0 );\n			toFocus.focus();\n			event.preventDefault();\n		}\n	},\n\n	_panelKeyDown : function( event ) {\n		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {\n			$( event.currentTarget ).prev().focus();\n		}\n	},\n\n	refresh: function() {\n		var options = this.options;\n		this._processPanels();\n\n		// was collapsed or no panel\n		if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {\n			options.active = false;\n			this.active = $();\n		// active false only when collapsible is true\n		} else if ( options.active === false ) {\n			this._activate( 0 );\n		// was active, but active panel is gone\n		} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {\n			// all remaining panel are disabled\n			if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {\n				options.active = false;\n				this.active = $();\n			// activate previous panel\n			} else {\n				this._activate( Math.max( 0, options.active - 1 ) );\n			}\n		// was active, active panel still exists\n		} else {\n			// make sure active index is correct\n			options.active = this.headers.index( this.active );\n		}\n\n		this._destroyIcons();\n\n		this._refresh();\n	},\n\n	_processPanels: function() {\n		this.headers = this.element.find( this.options.header )\n			.addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" );\n\n		this.headers.next()\n			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )\n			.filter(":not(.ui-accordion-content-active)")\n			.hide();\n	},\n\n	_refresh: function() {\n		var maxHeight,\n			options = this.options,\n			heightStyle = options.heightStyle,\n			parent = this.element.parent(),\n			accordionId = this.accordionId = "ui-accordion-" +\n				(this.element.attr( "id" ) || ++uid);\n\n		this.active = this._findActive( options.active )\n			.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )\n			.removeClass( "ui-corner-all" );\n		this.active.next()\n			.addClass( "ui-accordion-content-active" )\n			.show();\n\n		this.headers\n			.attr( "role", "tab" )\n			.each(function( i ) {\n				var header = $( this ),\n					headerId = header.attr( "id" ),\n					panel = header.next(),\n					panelId = panel.attr( "id" );\n				if ( !headerId ) {\n					headerId = accordionId + "-header-" + i;\n					header.attr( "id", headerId );\n				}\n				if ( !panelId ) {\n					panelId = accordionId + "-panel-" + i;\n					panel.attr( "id", panelId );\n				}\n				header.attr( "aria-controls", panelId );\n				panel.attr( "aria-labelledby", headerId );\n			})\n			.next()\n				.attr( "role", "tabpanel" );\n\n		this.headers\n			.not( this.active )\n			.attr({\n				"aria-selected": "false",\n				"aria-expanded": "false",\n				tabIndex: -1\n			})\n			.next()\n				.attr({\n					"aria-hidden": "true"\n				})\n				.hide();\n\n		// make sure at least one header is in the tab order\n		if ( !this.active.length ) {\n			this.headers.eq( 0 ).attr( "tabIndex", 0 );\n		} else {\n			this.active.attr({\n				"aria-selected": "true",\n				"aria-expanded": "true",\n				tabIndex: 0\n			})\n			.next()\n				.attr({\n					"aria-hidden": "false"\n				});\n		}\n\n		this._createIcons();\n\n		this._setupEvents( options.event );\n\n		if ( heightStyle === "fill" ) {\n			maxHeight = parent.height();\n			this.element.siblings( ":visible" ).each(function() {\n				var elem = $( this ),\n					position = elem.css( "position" );\n\n				if ( position === "absolute" || position === "fixed" ) {\n					return;\n				}\n				maxHeight -= elem.outerHeight( true );\n			});\n\n			this.headers.each(function() {\n				maxHeight -= $( this ).outerHeight( true );\n			});\n\n			this.headers.next()\n				.each(function() {\n					$( this ).height( Math.max( 0, maxHeight -\n						$( this ).innerHeight() + $( this ).height() ) );\n				})\n				.css( "overflow", "auto" );\n		} else if ( heightStyle === "auto" ) {\n			maxHeight = 0;\n			this.headers.next()\n				.each(function() {\n					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );\n				})\n				.height( maxHeight );\n		}\n	},\n\n	_activate: function( index ) {\n		var active = this._findActive( index )[ 0 ];\n\n		// trying to activate the already active panel\n		if ( active === this.active[ 0 ] ) {\n			return;\n		}\n\n		// trying to collapse, simulate a click on the currently active header\n		active = active || this.active[ 0 ];\n\n		this._eventHandler({\n			target: active,\n			currentTarget: active,\n			preventDefault: $.noop\n		});\n	},\n\n	_findActive: function( selector ) {\n		return typeof selector === "number" ? this.headers.eq( selector ) : $();\n	},\n\n	_setupEvents: function( event ) {\n		var events = {\n			keydown: "_keydown"\n		};\n		if ( event ) {\n			$.each( event.split(" "), function( index, eventName ) {\n				events[ eventName ] = "_eventHandler";\n			});\n		}\n\n		this._off( this.headers.add( this.headers.next() ) );\n		this._on( this.headers, events );\n		this._on( this.headers.next(), { keydown: "_panelKeyDown" });\n		this._hoverable( this.headers );\n		this._focusable( this.headers );\n	},\n\n	_eventHandler: function( event ) {\n		var options = this.options,\n			active = this.active,\n			clicked = $( event.currentTarget ),\n			clickedIsActive = clicked[ 0 ] === active[ 0 ],\n			collapsing = clickedIsActive && options.collapsible,\n			toShow = collapsing ? $() : clicked.next(),\n			toHide = active.next(),\n			eventData = {\n				oldHeader: active,\n				oldPanel: toHide,\n				newHeader: collapsing ? $() : clicked,\n				newPanel: toShow\n			};\n\n		event.preventDefault();\n\n		if (\n				// click on active header, but not collapsible\n				( clickedIsActive && !options.collapsible ) ||\n				// allow canceling activation\n				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {\n			return;\n		}\n\n		options.active = collapsing ? false : this.headers.index( clicked );\n\n		// when the call to ._toggle() comes after the class changes\n		// it causes a very odd bug in IE 8 (see #6720)\n		this.active = clickedIsActive ? $() : clicked;\n		this._toggle( eventData );\n\n		// switch classes\n		// corner classes on the previously active header stay after the animation\n		active.removeClass( "ui-accordion-header-active ui-state-active" );\n		if ( options.icons ) {\n			active.children( ".ui-accordion-header-icon" )\n				.removeClass( options.icons.activeHeader )\n				.addClass( options.icons.header );\n		}\n\n		if ( !clickedIsActive ) {\n			clicked\n				.removeClass( "ui-corner-all" )\n				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );\n			if ( options.icons ) {\n				clicked.children( ".ui-accordion-header-icon" )\n					.removeClass( options.icons.header )\n					.addClass( options.icons.activeHeader );\n			}\n\n			clicked\n				.next()\n				.addClass( "ui-accordion-content-active" );\n		}\n	},\n\n	_toggle: function( data ) {\n		var toShow = data.newPanel,\n			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;\n\n		// handle activating a panel during the animation for another activation\n		this.prevShow.add( this.prevHide ).stop( true, true );\n		this.prevShow = toShow;\n		this.prevHide = toHide;\n\n		if ( this.options.animate ) {\n			this._animate( toShow, toHide, data );\n		} else {\n			toHide.hide();\n			toShow.show();\n			this._toggleComplete( data );\n		}\n\n		toHide.attr({\n			"aria-hidden": "true"\n		});\n		toHide.prev().attr( "aria-selected", "false" );\n		// if we\'re switching panels, remove the old header from the tab order\n		// if we\'re opening from collapsed state, remove the previous header from the tab order\n		// if we\'re collapsing, then keep the collapsing header in the tab order\n		if ( toShow.length && toHide.length ) {\n			toHide.prev().attr({\n				"tabIndex": -1,\n				"aria-expanded": "false"\n			});\n		} else if ( toShow.length ) {\n			this.headers.filter(function() {\n				return $( this ).attr( "tabIndex" ) === 0;\n			})\n			.attr( "tabIndex", -1 );\n		}\n\n		toShow\n			.attr( "aria-hidden", "false" )\n			.prev()\n				.attr({\n					"aria-selected": "true",\n					tabIndex: 0,\n					"aria-expanded": "true"\n				});\n	},\n\n	_animate: function( toShow, toHide, data ) {\n		var total, easing, duration,\n			that = this,\n			adjust = 0,\n			down = toShow.length &&\n				( !toHide.length || ( toShow.index() < toHide.index() ) ),\n			animate = this.options.animate || {},\n			options = down && animate.down || animate,\n			complete = function() {\n				that._toggleComplete( data );\n			};\n\n		if ( typeof options === "number" ) {\n			duration = options;\n		}\n		if ( typeof options === "string" ) {\n			easing = options;\n		}\n		// fall back from options to animation in case of partial down settings\n		easing = easing || options.easing || animate.easing;\n		duration = duration || options.duration || animate.duration;\n\n		if ( !toHide.length ) {\n			return toShow.animate( showProps, duration, easing, complete );\n		}\n		if ( !toShow.length ) {\n			return toHide.animate( hideProps, duration, easing, complete );\n		}\n\n		total = toShow.show().outerHeight();\n		toHide.animate( hideProps, {\n			duration: duration,\n			easing: easing,\n			step: function( now, fx ) {\n				fx.now = Math.round( now );\n			}\n		});\n		toShow\n			.hide()\n			.animate( showProps, {\n				duration: duration,\n				easing: easing,\n				complete: complete,\n				step: function( now, fx ) {\n					fx.now = Math.round( now );\n					if ( fx.prop !== "height" ) {\n						adjust += fx.now;\n					} else if ( that.options.heightStyle !== "content" ) {\n						fx.now = Math.round( total - toHide.outerHeight() - adjust );\n						adjust = 0;\n					}\n				}\n			});\n	},\n\n	_toggleComplete: function( data ) {\n		var toHide = data.oldPanel;\n\n		toHide\n			.removeClass( "ui-accordion-content-active" )\n			.prev()\n				.removeClass( "ui-corner-top" )\n				.addClass( "ui-corner-all" );\n\n		// Work around for rendering bug in IE (#5421)\n		if ( toHide.length ) {\n			toHide.parent()[0].className = toHide.parent()[0].className;\n		}\n		this._trigger( "activate", null, data );\n	}\n});\n\n})( jQuery );\n',{address:"ui/accordion",metadata:{deps:["ui/core","ui/widget","theme/accordion.css!"],format:"global"}});
/*ui/core*/
System.define("ui/core",'/*!\n * jQuery UI Core 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/ui-core/\n */\n(function( $, undefined ) {\n\nvar uuid = 0,\n	runiqueId = /^ui-id-\\d+$/;\n\n// $.ui might exist from components with no dependencies, e.g., $.ui.position\n$.ui = $.ui || {};\n\n$.extend( $.ui, {\n	version: "1.10.4",\n\n	keyCode: {\n		BACKSPACE: 8,\n		COMMA: 188,\n		DELETE: 46,\n		DOWN: 40,\n		END: 35,\n		ENTER: 13,\n		ESCAPE: 27,\n		HOME: 36,\n		LEFT: 37,\n		NUMPAD_ADD: 107,\n		NUMPAD_DECIMAL: 110,\n		NUMPAD_DIVIDE: 111,\n		NUMPAD_ENTER: 108,\n		NUMPAD_MULTIPLY: 106,\n		NUMPAD_SUBTRACT: 109,\n		PAGE_DOWN: 34,\n		PAGE_UP: 33,\n		PERIOD: 190,\n		RIGHT: 39,\n		SPACE: 32,\n		TAB: 9,\n		UP: 38\n	}\n});\n\n// plugins\n$.fn.extend({\n	focus: (function( orig ) {\n		return function( delay, fn ) {\n			return typeof delay === "number" ?\n				this.each(function() {\n					var elem = this;\n					setTimeout(function() {\n						$( elem ).focus();\n						if ( fn ) {\n							fn.call( elem );\n						}\n					}, delay );\n				}) :\n				orig.apply( this, arguments );\n		};\n	})( $.fn.focus ),\n\n	scrollParent: function() {\n		var scrollParent;\n		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {\n			scrollParent = this.parents().filter(function() {\n				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));\n			}).eq(0);\n		} else {\n			scrollParent = this.parents().filter(function() {\n				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));\n			}).eq(0);\n		}\n\n		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;\n	},\n\n	zIndex: function( zIndex ) {\n		if ( zIndex !== undefined ) {\n			return this.css( "zIndex", zIndex );\n		}\n\n		if ( this.length ) {\n			var elem = $( this[ 0 ] ), position, value;\n			while ( elem.length && elem[ 0 ] !== document ) {\n				// Ignore z-index if position is set to a value where z-index is ignored by the browser\n				// This makes behavior of this function consistent across browsers\n				// WebKit always returns auto if the element is positioned\n				position = elem.css( "position" );\n				if ( position === "absolute" || position === "relative" || position === "fixed" ) {\n					// IE returns 0 when zIndex is not specified\n					// other browsers return a string\n					// we ignore the case of nested elements with an explicit value of 0\n					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>\n					value = parseInt( elem.css( "zIndex" ), 10 );\n					if ( !isNaN( value ) && value !== 0 ) {\n						return value;\n					}\n				}\n				elem = elem.parent();\n			}\n		}\n\n		return 0;\n	},\n\n	uniqueId: function() {\n		return this.each(function() {\n			if ( !this.id ) {\n				this.id = "ui-id-" + (++uuid);\n			}\n		});\n	},\n\n	removeUniqueId: function() {\n		return this.each(function() {\n			if ( runiqueId.test( this.id ) ) {\n				$( this ).removeAttr( "id" );\n			}\n		});\n	}\n});\n\n// selectors\nfunction focusable( element, isTabIndexNotNaN ) {\n	var map, mapName, img,\n		nodeName = element.nodeName.toLowerCase();\n	if ( "area" === nodeName ) {\n		map = element.parentNode;\n		mapName = map.name;\n		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {\n			return false;\n		}\n		img = $( "img[usemap=#" + mapName + "]" )[0];\n		return !!img && visible( img );\n	}\n	return ( /input|select|textarea|button|object/.test( nodeName ) ?\n		!element.disabled :\n		"a" === nodeName ?\n			element.href || isTabIndexNotNaN :\n			isTabIndexNotNaN) &&\n		// the element and all of its ancestors must be visible\n		visible( element );\n}\n\nfunction visible( element ) {\n	return $.expr.filters.visible( element ) &&\n		!$( element ).parents().addBack().filter(function() {\n			return $.css( this, "visibility" ) === "hidden";\n		}).length;\n}\n\n$.extend( $.expr[ ":" ], {\n	data: $.expr.createPseudo ?\n		$.expr.createPseudo(function( dataName ) {\n			return function( elem ) {\n				return !!$.data( elem, dataName );\n			};\n		}) :\n		// support: jQuery <1.8\n		function( elem, i, match ) {\n			return !!$.data( elem, match[ 3 ] );\n		},\n\n	focusable: function( element ) {\n		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );\n	},\n\n	tabbable: function( element ) {\n		var tabIndex = $.attr( element, "tabindex" ),\n			isTabIndexNaN = isNaN( tabIndex );\n		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\n	}\n});\n\n// support: jQuery <1.8\nif ( !$( "<a>" ).outerWidth( 1 ).jquery ) {\n	$.each( [ "Width", "Height" ], function( i, name ) {\n		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],\n			type = name.toLowerCase(),\n			orig = {\n				innerWidth: $.fn.innerWidth,\n				innerHeight: $.fn.innerHeight,\n				outerWidth: $.fn.outerWidth,\n				outerHeight: $.fn.outerHeight\n			};\n\n		function reduce( elem, size, border, margin ) {\n			$.each( side, function() {\n				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;\n				if ( border ) {\n					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;\n				}\n				if ( margin ) {\n					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;\n				}\n			});\n			return size;\n		}\n\n		$.fn[ "inner" + name ] = function( size ) {\n			if ( size === undefined ) {\n				return orig[ "inner" + name ].call( this );\n			}\n\n			return this.each(function() {\n				$( this ).css( type, reduce( this, size ) + "px" );\n			});\n		};\n\n		$.fn[ "outer" + name] = function( size, margin ) {\n			if ( typeof size !== "number" ) {\n				return orig[ "outer" + name ].call( this, size );\n			}\n\n			return this.each(function() {\n				$( this).css( type, reduce( this, size, true, margin ) + "px" );\n			});\n		};\n	});\n}\n\n// support: jQuery <1.8\nif ( !$.fn.addBack ) {\n	$.fn.addBack = function( selector ) {\n		return this.add( selector == null ?\n			this.prevObject : this.prevObject.filter( selector )\n		);\n	};\n}\n\n// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\nif ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {\n	$.fn.removeData = (function( removeData ) {\n		return function( key ) {\n			if ( arguments.length ) {\n				return removeData.call( this, $.camelCase( key ) );\n			} else {\n				return removeData.call( this );\n			}\n		};\n	})( $.fn.removeData );\n}\n\n\n\n\n\n// deprecated\n$.ui.ie = !!/msie [\\w.]+/.exec( navigator.userAgent.toLowerCase() );\n\n$.support.selectstart = "onselectstart" in document.createElement( "div" );\n$.fn.extend({\n	disableSelection: function() {\n		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +\n			".ui-disableSelection", function( event ) {\n				event.preventDefault();\n			});\n	},\n\n	enableSelection: function() {\n		return this.unbind( ".ui-disableSelection" );\n	}\n});\n\n$.extend( $.ui, {\n	// $.ui.plugin is deprecated. Use $.widget() extensions instead.\n	plugin: {\n		add: function( module, option, set ) {\n			var i,\n				proto = $.ui[ module ].prototype;\n			for ( i in set ) {\n				proto.plugins[ i ] = proto.plugins[ i ] || [];\n				proto.plugins[ i ].push( [ option, set[ i ] ] );\n			}\n		},\n		call: function( instance, name, args ) {\n			var i,\n				set = instance.plugins[ name ];\n			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {\n				return;\n			}\n\n			for ( i = 0; i < set.length; i++ ) {\n				if ( instance.options[ set[ i ][ 0 ] ] ) {\n					set[ i ][ 1 ].apply( instance.element, args );\n				}\n			}\n		}\n	},\n\n	// only used by resizable\n	hasScroll: function( el, a ) {\n\n		//If overflow is hidden, the element might have extra content, but the user wants to hide it\n		if ( $( el ).css( "overflow" ) === "hidden") {\n			return false;\n		}\n\n		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",\n			has = false;\n\n		if ( el[ scroll ] > 0 ) {\n			return true;\n		}\n\n		// TODO: determine which cases actually cause this to happen\n		// if the element doesn\'t have the scroll set, see if it\'s possible to\n		// set the scroll\n		el[ scroll ] = 1;\n		has = ( el[ scroll ] > 0 );\n		el[ scroll ] = 0;\n		return has;\n	}\n});\n\n})( jQuery );\n',{address:"ui/core",metadata:{deps:["jquery","theme/core.css!","theme/theme.css!"],format:"global"}});
/*ui/widget*/
System.define("ui/widget",'/*!\n * jQuery UI Widget 1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/jQuery.widget/\n */\n(function( $, undefined ) {\n\nvar uuid = 0,\n	slice = Array.prototype.slice,\n	_cleanData = $.cleanData;\n$.cleanData = function( elems ) {\n	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\n		try {\n			$( elem ).triggerHandler( "remove" );\n		// http://bugs.jquery.com/ticket/8235\n		} catch( e ) {}\n	}\n	_cleanData( elems );\n};\n\n$.widget = function( name, base, prototype ) {\n	var fullName, existingConstructor, constructor, basePrototype,\n		// proxiedPrototype allows the provided prototype to remain unmodified\n		// so that it can be used as a mixin for multiple widgets (#8876)\n		proxiedPrototype = {},\n		namespace = name.split( "." )[ 0 ];\n\n	name = name.split( "." )[ 1 ];\n	fullName = namespace + "-" + name;\n\n	if ( !prototype ) {\n		prototype = base;\n		base = $.Widget;\n	}\n\n	// create selector for plugin\n	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {\n		return !!$.data( elem, fullName );\n	};\n\n	$[ namespace ] = $[ namespace ] || {};\n	existingConstructor = $[ namespace ][ name ];\n	constructor = $[ namespace ][ name ] = function( options, element ) {\n		// allow instantiation without "new" keyword\n		if ( !this._createWidget ) {\n			return new constructor( options, element );\n		}\n\n		// allow instantiation without initializing for simple inheritance\n		// must use "new" keyword (the code above always passes args)\n		if ( arguments.length ) {\n			this._createWidget( options, element );\n		}\n	};\n	// extend with the existing constructor to carry over any static properties\n	$.extend( constructor, existingConstructor, {\n		version: prototype.version,\n		// copy the object used to create the prototype in case we need to\n		// redefine the widget later\n		_proto: $.extend( {}, prototype ),\n		// track widgets that inherit from this widget in case this widget is\n		// redefined after a widget inherits from it\n		_childConstructors: []\n	});\n\n	basePrototype = new base();\n	// we need to make the options hash a property directly on the new instance\n	// otherwise we\'ll modify the options hash on the prototype that we\'re\n	// inheriting from\n	basePrototype.options = $.widget.extend( {}, basePrototype.options );\n	$.each( prototype, function( prop, value ) {\n		if ( !$.isFunction( value ) ) {\n			proxiedPrototype[ prop ] = value;\n			return;\n		}\n		proxiedPrototype[ prop ] = (function() {\n			var _super = function() {\n					return base.prototype[ prop ].apply( this, arguments );\n				},\n				_superApply = function( args ) {\n					return base.prototype[ prop ].apply( this, args );\n				};\n			return function() {\n				var __super = this._super,\n					__superApply = this._superApply,\n					returnValue;\n\n				this._super = _super;\n				this._superApply = _superApply;\n\n				returnValue = value.apply( this, arguments );\n\n				this._super = __super;\n				this._superApply = __superApply;\n\n				return returnValue;\n			};\n		})();\n	});\n	constructor.prototype = $.widget.extend( basePrototype, {\n		// TODO: remove support for widgetEventPrefix\n		// always use the name + a colon as the prefix, e.g., draggable:start\n		// don\'t prefix for widgets that aren\'t DOM-based\n		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name\n	}, proxiedPrototype, {\n		constructor: constructor,\n		namespace: namespace,\n		widgetName: name,\n		widgetFullName: fullName\n	});\n\n	// If this widget is being redefined then we need to find all widgets that\n	// are inheriting from it and redefine all of them so that they inherit from\n	// the new version of this widget. We\'re essentially trying to replace one\n	// level in the prototype chain.\n	if ( existingConstructor ) {\n		$.each( existingConstructor._childConstructors, function( i, child ) {\n			var childPrototype = child.prototype;\n\n			// redefine the child widget using the same prototype that was\n			// originally used, but inherit from the new version of the base\n			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );\n		});\n		// remove the list of existing child constructors from the old constructor\n		// so the old child constructors can be garbage collected\n		delete existingConstructor._childConstructors;\n	} else {\n		base._childConstructors.push( constructor );\n	}\n\n	$.widget.bridge( name, constructor );\n};\n\n$.widget.extend = function( target ) {\n	var input = slice.call( arguments, 1 ),\n		inputIndex = 0,\n		inputLength = input.length,\n		key,\n		value;\n	for ( ; inputIndex < inputLength; inputIndex++ ) {\n		for ( key in input[ inputIndex ] ) {\n			value = input[ inputIndex ][ key ];\n			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\n				// Clone objects\n				if ( $.isPlainObject( value ) ) {\n					target[ key ] = $.isPlainObject( target[ key ] ) ?\n						$.widget.extend( {}, target[ key ], value ) :\n						// Don\'t extend strings, arrays, etc. with objects\n						$.widget.extend( {}, value );\n				// Copy everything else by reference\n				} else {\n					target[ key ] = value;\n				}\n			}\n		}\n	}\n	return target;\n};\n\n$.widget.bridge = function( name, object ) {\n	var fullName = object.prototype.widgetFullName || name;\n	$.fn[ name ] = function( options ) {\n		var isMethodCall = typeof options === "string",\n			args = slice.call( arguments, 1 ),\n			returnValue = this;\n\n		// allow multiple hashes to be passed on init\n		options = !isMethodCall && args.length ?\n			$.widget.extend.apply( null, [ options ].concat(args) ) :\n			options;\n\n		if ( isMethodCall ) {\n			this.each(function() {\n				var methodValue,\n					instance = $.data( this, fullName );\n				if ( !instance ) {\n					return $.error( "cannot call methods on " + name + " prior to initialization; " +\n						"attempted to call method \'" + options + "\'" );\n				}\n				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {\n					return $.error( "no such method \'" + options + "\' for " + name + " widget instance" );\n				}\n				methodValue = instance[ options ].apply( instance, args );\n				if ( methodValue !== instance && methodValue !== undefined ) {\n					returnValue = methodValue && methodValue.jquery ?\n						returnValue.pushStack( methodValue.get() ) :\n						methodValue;\n					return false;\n				}\n			});\n		} else {\n			this.each(function() {\n				var instance = $.data( this, fullName );\n				if ( instance ) {\n					instance.option( options || {} )._init();\n				} else {\n					$.data( this, fullName, new object( options, this ) );\n				}\n			});\n		}\n\n		return returnValue;\n	};\n};\n\n$.Widget = function( /* options, element */ ) {};\n$.Widget._childConstructors = [];\n\n$.Widget.prototype = {\n	widgetName: "widget",\n	widgetEventPrefix: "",\n	defaultElement: "<div>",\n	options: {\n		disabled: false,\n\n		// callbacks\n		create: null\n	},\n	_createWidget: function( options, element ) {\n		element = $( element || this.defaultElement || this )[ 0 ];\n		this.element = $( element );\n		this.uuid = uuid++;\n		this.eventNamespace = "." + this.widgetName + this.uuid;\n		this.options = $.widget.extend( {},\n			this.options,\n			this._getCreateOptions(),\n			options );\n\n		this.bindings = $();\n		this.hoverable = $();\n		this.focusable = $();\n\n		if ( element !== this ) {\n			$.data( element, this.widgetFullName, this );\n			this._on( true, this.element, {\n				remove: function( event ) {\n					if ( event.target === element ) {\n						this.destroy();\n					}\n				}\n			});\n			this.document = $( element.style ?\n				// element within the document\n				element.ownerDocument :\n				// element is window or document\n				element.document || element );\n			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );\n		}\n\n		this._create();\n		this._trigger( "create", null, this._getCreateEventData() );\n		this._init();\n	},\n	_getCreateOptions: $.noop,\n	_getCreateEventData: $.noop,\n	_create: $.noop,\n	_init: $.noop,\n\n	destroy: function() {\n		this._destroy();\n		// we can probably remove the unbind calls in 2.0\n		// all event bindings should go through this._on()\n		this.element\n			.unbind( this.eventNamespace )\n			// 1.9 BC for #7810\n			// TODO remove dual storage\n			.removeData( this.widgetName )\n			.removeData( this.widgetFullName )\n			// support: jquery <1.6.3\n			// http://bugs.jquery.com/ticket/9413\n			.removeData( $.camelCase( this.widgetFullName ) );\n		this.widget()\n			.unbind( this.eventNamespace )\n			.removeAttr( "aria-disabled" )\n			.removeClass(\n				this.widgetFullName + "-disabled " +\n				"ui-state-disabled" );\n\n		// clean up events and states\n		this.bindings.unbind( this.eventNamespace );\n		this.hoverable.removeClass( "ui-state-hover" );\n		this.focusable.removeClass( "ui-state-focus" );\n	},\n	_destroy: $.noop,\n\n	widget: function() {\n		return this.element;\n	},\n\n	option: function( key, value ) {\n		var options = key,\n			parts,\n			curOption,\n			i;\n\n		if ( arguments.length === 0 ) {\n			// don\'t return a reference to the internal hash\n			return $.widget.extend( {}, this.options );\n		}\n\n		if ( typeof key === "string" ) {\n			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }\n			options = {};\n			parts = key.split( "." );\n			key = parts.shift();\n			if ( parts.length ) {\n				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\n				for ( i = 0; i < parts.length - 1; i++ ) {\n					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\n					curOption = curOption[ parts[ i ] ];\n				}\n				key = parts.pop();\n				if ( arguments.length === 1 ) {\n					return curOption[ key ] === undefined ? null : curOption[ key ];\n				}\n				curOption[ key ] = value;\n			} else {\n				if ( arguments.length === 1 ) {\n					return this.options[ key ] === undefined ? null : this.options[ key ];\n				}\n				options[ key ] = value;\n			}\n		}\n\n		this._setOptions( options );\n\n		return this;\n	},\n	_setOptions: function( options ) {\n		var key;\n\n		for ( key in options ) {\n			this._setOption( key, options[ key ] );\n		}\n\n		return this;\n	},\n	_setOption: function( key, value ) {\n		this.options[ key ] = value;\n\n		if ( key === "disabled" ) {\n			this.widget()\n				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )\n				.attr( "aria-disabled", value );\n			this.hoverable.removeClass( "ui-state-hover" );\n			this.focusable.removeClass( "ui-state-focus" );\n		}\n\n		return this;\n	},\n\n	enable: function() {\n		return this._setOption( "disabled", false );\n	},\n	disable: function() {\n		return this._setOption( "disabled", true );\n	},\n\n	_on: function( suppressDisabledCheck, element, handlers ) {\n		var delegateElement,\n			instance = this;\n\n		// no suppressDisabledCheck flag, shuffle arguments\n		if ( typeof suppressDisabledCheck !== "boolean" ) {\n			handlers = element;\n			element = suppressDisabledCheck;\n			suppressDisabledCheck = false;\n		}\n\n		// no element argument, shuffle and use this.element\n		if ( !handlers ) {\n			handlers = element;\n			element = this.element;\n			delegateElement = this.widget();\n		} else {\n			// accept selectors, DOM elements\n			element = delegateElement = $( element );\n			this.bindings = this.bindings.add( element );\n		}\n\n		$.each( handlers, function( event, handler ) {\n			function handlerProxy() {\n				// allow widgets to customize the disabled handling\n				// - disabled as an array instead of boolean\n				// - disabled class as method for disabling individual parts\n				if ( !suppressDisabledCheck &&\n						( instance.options.disabled === true ||\n							$( this ).hasClass( "ui-state-disabled" ) ) ) {\n					return;\n				}\n				return ( typeof handler === "string" ? instance[ handler ] : handler )\n					.apply( instance, arguments );\n			}\n\n			// copy the guid so direct unbinding works\n			if ( typeof handler !== "string" ) {\n				handlerProxy.guid = handler.guid =\n					handler.guid || handlerProxy.guid || $.guid++;\n			}\n\n			var match = event.match( /^(\\w+)\\s*(.*)$/ ),\n				eventName = match[1] + instance.eventNamespace,\n				selector = match[2];\n			if ( selector ) {\n				delegateElement.delegate( selector, eventName, handlerProxy );\n			} else {\n				element.bind( eventName, handlerProxy );\n			}\n		});\n	},\n\n	_off: function( element, eventName ) {\n		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;\n		element.unbind( eventName ).undelegate( eventName );\n	},\n\n	_delay: function( handler, delay ) {\n		function handlerProxy() {\n			return ( typeof handler === "string" ? instance[ handler ] : handler )\n				.apply( instance, arguments );\n		}\n		var instance = this;\n		return setTimeout( handlerProxy, delay || 0 );\n	},\n\n	_hoverable: function( element ) {\n		this.hoverable = this.hoverable.add( element );\n		this._on( element, {\n			mouseenter: function( event ) {\n				$( event.currentTarget ).addClass( "ui-state-hover" );\n			},\n			mouseleave: function( event ) {\n				$( event.currentTarget ).removeClass( "ui-state-hover" );\n			}\n		});\n	},\n\n	_focusable: function( element ) {\n		this.focusable = this.focusable.add( element );\n		this._on( element, {\n			focusin: function( event ) {\n				$( event.currentTarget ).addClass( "ui-state-focus" );\n			},\n			focusout: function( event ) {\n				$( event.currentTarget ).removeClass( "ui-state-focus" );\n			}\n		});\n	},\n\n	_trigger: function( type, event, data ) {\n		var prop, orig,\n			callback = this.options[ type ];\n\n		data = data || {};\n		event = $.Event( event );\n		event.type = ( type === this.widgetEventPrefix ?\n			type :\n			this.widgetEventPrefix + type ).toLowerCase();\n		// the original event may come from any element\n		// so we need to reset the target on the new event\n		event.target = this.element[ 0 ];\n\n		// copy original event properties over to the new event\n		orig = event.originalEvent;\n		if ( orig ) {\n			for ( prop in orig ) {\n				if ( !( prop in event ) ) {\n					event[ prop ] = orig[ prop ];\n				}\n			}\n		}\n\n		this.element.trigger( event, data );\n		return !( $.isFunction( callback ) &&\n			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||\n			event.isDefaultPrevented() );\n	}\n};\n\n$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {\n	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {\n		if ( typeof options === "string" ) {\n			options = { effect: options };\n		}\n		var hasOptions,\n			effectName = !options ?\n				method :\n				options === true || typeof options === "number" ?\n					defaultEffect :\n					options.effect || defaultEffect;\n		options = options || {};\n		if ( typeof options === "number" ) {\n			options = { duration: options };\n		}\n		hasOptions = !$.isEmptyObject( options );\n		options.complete = callback;\n		if ( options.delay ) {\n			element.delay( options.delay );\n		}\n		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\n			element[ method ]( options );\n		} else if ( effectName !== method && element[ effectName ] ) {\n			element[ effectName ]( options.duration, options.easing, callback );\n		} else {\n			element.queue(function( next ) {\n				$( this )[ method ]();\n				if ( callback ) {\n					callback.call( element[ 0 ] );\n				}\n				next();\n			});\n		}\n	};\n});\n\n})( jQuery );\n',{address:"ui/widget",metadata:{deps:["jquery"],format:"global"}});
/*components/jquery-ui/jquery-ui.stache!can/view/stache/system*/
define("components/jquery-ui/jquery-ui.stache!can/view/stache/system",["can/view/stache/stache"],function(e){return e("<div {{accordion}}>\n  <h3>Section 1</h3>\n  <div>\n    <p>\n    Mauris mauris ante, blandit et, ultrices a, suscipit eget, quam. Integer\n    ut neque. Vivamus nisi metus, molestie vel, gravida in, condimentum sit\n    amet, nunc. Nam a nibh. Donec suscipit eros. Nam mi. Proin viverra leo ut\n    odio. Curabitur malesuada. Vestibulum a velit eu ante scelerisque vulputate.\n    </p>\n  </div>\n  <h3>Section 2</h3>\n  <div>\n    <p>\n    Sed non urna. Donec et ante. Phasellus eu ligula. Vestibulum sit amet\n    purus. Vivamus hendrerit, dolor at aliquet laoreet, mauris turpis porttitor\n    velit, faucibus interdum tellus libero ac justo. Vivamus non quam. In\n    suscipit faucibus urna.\n    </p>\n  </div>\n  <h3>Section 3</h3>\n  <div>\n    <p>\n    Nam enim risus, molestie et, porta ac, aliquam ac, risus. Quisque lobortis.\n    Phasellus pellentesque purus in massa. Aenean in pede. Phasellus ac libero\n    ac tellus pellentesque semper. Sed ac felis. Sed commodo, magna quis\n    lacinia ornare, quam ante aliquam nisi, eu iaculis leo purus venenatis dui.\n    </p>\n    <ul>\n      <li>List item one</li>\n      <li>List item two</li>\n      <li>List item three</li>\n    </ul>\n  </div>\n  <h3>Section 4</h3>\n  <div>\n    <p>\n    Cras dictum. Pellentesque habitant morbi tristique senectus et netus\n    et malesuada fames ac turpis egestas. Vestibulum ante ipsum primis in\n    faucibus orci luctus et ultrices posuere cubilia Curae; Aenean lacinia\n    mauris vel est.\n    </p>\n    <p>\n    Suspendisse eu nisl. Nullam ut libero. Integer dignissim consequat lectus.\n    Class aptent taciti sociosqu ad litora torquent per conubia nostra, per\n    inceptos himenaeos.\n    </p>\n  </div>\n</div>")});
